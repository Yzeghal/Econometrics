create_package("C:/Users/tayoy/Documents/StatapR")
create_package("C:/Users/tayoy/Documents/StatapR")
library(StatapR)
install(StatapR)
help("install")
install('C:\Users\tayoy\Documents\StatapR')
install('C:/Users/tayoy/Documents/StatapR')
library(StatapR)
install('C:/Users/tayoy/Documents/StatapR')
library(StatapR)
argonautes
argonautes()
StatapR:argonautes()
sessionInfo()
help(probit)
??probit
??logit
help(logit)
help(linspace)
??linspace
package(pracma)
library(pracma)
xabs=linspace(-5,5,n=10000)
ll=dlog(xabs)
ll=dlogis(xabs)
nor=dnorm(xabs)
plot(xabs,ll, type='l')
lines(xabs,nor, type='l', col='blue')
plot(xabs,nor, type='l', col='blue')
lines(xabs,ll, type='l', col='blue')
library(matrixcalc) #for matrix inversion and others
library(MASS)#to generate multivariate data
library(lmtest) #to perform test with specified indications with coeftest
library(sandwich) # to compute heteroscedasticity robust tests : vcovHC(reg, type = "HC0")
#generating data
#set.seed(0)
eps=rnorm(1000, mean=0, sd=0.2)
l=2
d=diag(l)
d2=cbind(d,matrix(rep(0,l)))[,l:(l+1)]
d<-d+d2
sigma<-(d+t(d))/2
beta= matrix(c(2,4))
x=mvrnorm(1000,c(0,0),sigma[1:l,1:l])
y=x%*%beta+eps
y=y+x[,1]^2*x[,2]^3 #to add some omitted variable
coefs<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
M=t(X)%*%X
X=cbind(rep(1,nx),X)
if (det(M)==0){stop('Matrix X\'X non inversible !')}
matrix.inverse(t(X)%*%X)%*%(t(X)%*%Y)
}
estimate<-function(X,Beta_hat){
nx=dim(X)[1]
X=cbind(matrix(rep(1),nx),X)
Y_hat=X%*%Beta_hat
}
asymptotic_variance<-function(X,Y){
nx=dim(X)[1]
beta_hat=coefs(X,Y)
eps_hat=Y-estimate(X,beta_hat)
d_eps=diag(as.vector(eps_hat))
#print(dim(d_eps))
X=cbind(rep(1,nx),X)
X_eps = d_eps%*%X
#print(dim(X_eps))
middle_term = t(X_eps)%*%(X_eps)*nx
#print(dim(middle_term))
sandwich_term= matrix.inverse(t(X)%*%X)
#print(dim(sandwich_term))
var = sandwich_term %*% middle_term %*% sandwich_term
}
standard_errors<-function (var,nx){
s=matrix(sqrt(diag(var)/nx))
}
student_t<-function(Beta_hat,sd,hyp = 0){
t=(Beta_hat-hyp)/sd
return(t)
}
p_values<-function(Beta_hat, sd ,nx , hyp = 0){
deg_freedom = nx-length(Beta_hat)
t=abs(student_t(Beta_hat, sd, hyp))
p=2*(1-(pt(t,deg_freedom)))
return(p)
}
reg_OLS<-function(X,Y,hyp=0){
if (!is.matrix(X)){
stop("X should be a matrix")
}
if (!is.matrix(Y)){
stop("Y should be a matrix")
}
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){
message=paste(nx, 'Observations for X\n',ny, 'observations for Y\nMake sure Nx==Ny')
stop(message)}
Beta_hat=coefs(X,Y)
Y_hat=estimate(X,Beta_hat)
eps_hat=Y-Y_hat
asvar=asymptotic_variance(X,Y)
se=standard_errors(asvar,nx)
t=student_t(Beta_hat,se,hyp)
p=p_values(Beta_hat,se,nx,hyp)
R2=sum((Y_hat-mean(Y_hat))^2)/sum((Y-mean(Y))^2)
if (sum(abs(hyp))==0){hyp = rep(0,length(Beta_hat))}
values = matrix(c(Beta_hat,se,t,p,hyp), ncol=5)
colnames(values)=c('Beta_hat', 'Std_Err','Student_t','p-values', 'H0_hyp')
return(list('R2'=R2, 'values' = values))
}
#homemade model fitting
ols<-reg_OLS(x,y, hyp=c(0,0,0))
print(ols)
#built-in model fitting
reg=lm(y~x)
tests=coeftest(reg, vcov = vcovHC(reg, type = "HC0")) #performs tests on the model reg with the variance matrix calculated with vcovHC
#comparaison
print(ols$values[,1]-tests[,1]) #difference between built-in and homemade estimators
print(ols$values[,2]-tests[,2]) #difference between built-in and homemade std error
print(ols$values[,2]-tests[,2]) #difference between built-in and homemade std error
coefs<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
X=cbind(rep(1,nx),X)
M=t(X)%*%X
if (det(M)==0){stop('Matrix X\'X non inversible !')}
matrix.inverse(t(X)%*%X)%*%(t(X)%*%Y)
}
coefs2<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
X=cbind(rep(1,nx),X)
M1=0
for (i in 1:nx){
M1=M1+t(X[i,])%*% X[i,]
}
print(M1)
}
coefs2(x,y)
x[2,]
x
x[2,]
t(x[2,])
x[2,]%*%t(x[2])
matrix(x[2,])%*%t(x[2])
x[2,]
matrix(x[2,])
matrix(x[2,])%*%t(x[2,])
coefs2<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
X=cbind(rep(1,nx),X)
M1=0
for (i in 1:nx){
M1=M1+matrix(X[i,])%*% t(X[i,])
}
print(M1)
}
coefs2(X)
coefs2(x)
coefs2(x,y)
coefs2<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
X=cbind(rep(1,nx),X)
M1=0
for (i in 1:nx){
M1=M1+matrix(X[i,])%*% t(X[i,])
}
M1=M1/nx
print(M1)
}
coefs2(x,y)
sigma<-(d+t(d))/2
beta= matrix(c(2,4))
x=mvrnorm(1000,c(0,0),sigma[1:l,1:l])
ibrary(matrixcalc) #for matrix inversion and others
library(MASS)#to generate multivariate data
library(lmtest) #to perform test with specified indications with coeftest
lib
library(matrixcalc) #for matrix inversion and others
library(MASS)#to generate multivariate data
library(lmtest) #to perform test with specified indications with coeftest
library(sandwich) # to compute heteroscedasticity robust tests : vcovHC(reg, type = "HC0")
#generating data
#set.seed(0)
eps=rnorm(1000, mean=0, sd=0.2)
l=2
d=diag(l)
d2=cbind(d,matrix(rep(0,l)))[,l:(l+1)]
d<-d+d2
sigma<-(d+t(d))/2
beta= matrix(c(2,4))
x=mvrnorm(1000,c(0,0),sigma[1:l,1:l])
y=x%*%beta+eps
coefs2(x,y)
sigma
coefs2<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
X=cbind(rep(1,nx),X)
M1=0
M2=0
for (i in 1:nx){
M1=M1+matrix(X[i,])%*% t(X[i,])
}
M1=matrix.inverse(M1/nx)
for (i in 1:nx){
M2=M2+(X[i,])*Y[i,]
}
M2=M2/nx
print(M2)
}
coefs2(x,y)
coefs2<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
X=cbind(rep(1,nx),X)
M1=0
M2=0
for (i in 1:nx){
M1=M1+matrix(X[i,])%*% t(X[i,])
}
M1=matrix.inverse(M1/nx)
for (i in 1:nx){
M2=M2+matrix(X[i,])*Y[i,]
}
M2=M2/nx
print(M2)
}
coefs2(x,y)
coefs2<-function(X,Y){
nx=dim(X)[1]
ny=dim(Y)[1]
if (nx!=ny){stop('not the same number of observations')}
X=cbind(rep(1,nx),X)
M1=0
M2=0
for (i in 1:nx){
M1=M1+matrix(X[i,])%*% t(X[i,])
}
M1=matrix.inverse(M1/nx)
for (i in 1:nx){
M2=M2+matrix(X[i,])*Y[i,]
}
M2=M2/nx
Beta_hat = M1%*%M2
return(Beta_hat)
}
coefs2(x,t)
t
coefs2(x,y)
coefs(x,y)
lm(y~x).coefs
lm(y~x)$coefs
lm(y~x)
sigma
s
s=sigma
s[2]=NA
s
sum(s)
sum(s, na.rm=TRUE)
s%*%s
s[s==NA]
is.na
is.na(S)
is.na(s)
s[is.na(s)]
as.vector([is.na(s)])
as.vector(is.na(s))
s[as.vector(is.na(s))]
s[as.vector(!is.na(s))]
replace(NA,s,0)
s=replace(NA,s,0)
s
s
s
sss
naaaaaaaa
getwd()
# M is a n*n*length(Beta_0)+1 array :
# Its 2 first dimensions are lines and columns.
# The last dimension is :
# (1, X1,...,Xk,Yk) with length 1+length(Beta_0) because Beta_0 includes
# a constant coef
setwd("C:/Users/tayoy/Documents/GitHub/Econometrics")
file = paste(getwd(),"/Basic Regression.R")
source(file =file)
file = paste(getwd(),"/Basic Regression.R",sep="")
source(file =file)
x1=as.vector(Xij[,,2])
x2=as.vector(Xij[,,3])
x=matrix(c(x1,x2),ncol=2)
y=matrix(as.vector(Yij[,]))
Beta_hat=coefs_barbarian(x,y)
Beta_hat
diag(M)
M
# Script for MCO in the case of jointly echangeable and dissociated arrays.
library(matrixcalc) #for matrix inversion and others
library(MASS)#to generate multivariate data
library(lmtest) #to perform test with specified indications with coeftest
library(sandwich) # to compute heteroscedasticity robust tests : vcovHC(reg, type = "HC0")
#generating data
Beta_0 = matrix(c(1,2,4)) #constant coefficient included
n=10
Ui=runif(n,0,1)
Uj=runif(n,0,1)
Uij=matrix(runif(n^2,0,1),ncol=n)
f<-function(Ui,Uj,Uij){
#function f
Xij=matrix(c(1,log(Ui),Ui+Uj)) #constant added here
# print(Xij)
Yij=t(Beta_0)%*%matrix(Xij)+Uij/10-0.05
# print(Yij)
return (array(c(Xij,Yij),c(1,length(Beta_0)+1)))
}
M=array(0,c(n,n,length(Beta_0)+1))
for(i in 1:n){
for(j in 1:n){
M[i,j,]=f(Ui[i],Uj[j],Uij[i,j])
}
}
Xij=M[,,1:length(Beta_0)]
Yij=M[,,length(Beta_0)+1]
# M is a n*n*length(Beta_0)+1 array :
# Its 2 first dimensions are lines and columns.
# The last dimension is :
# (1, X1,...,Xk,Yk) with length 1+length(Beta_0) because Beta_0 includes
# a constant coef
setwd("C:/Users/tayoy/Documents/GitHub/Econometrics")
file = paste(getwd(),"/Basic Regression.R",sep="")
source(file =file)
x1=as.vector(Xij[,,2])
x2=as.vector(Xij[,,3])
x=matrix(c(x1,x2),ncol=2)
y=matrix(as.vector(Yij[,]))
Beta_hat=coefs_barbarian(x,y)
Beta_hat
M
diag(M)
M_na=M
for (i in 1:n){
M_na[i,i,]=NA
}
M_na
for (i in 1:n){
M[i,i,]=NA
}
Xij=M[,,1:length(Beta_0)]
Yij=M[,,length(Beta_0)+1]
Yij
Xij
x1=as.vector(Xij[,,2])
x1
x2
x2=as.vector(Xij[,,3])
x=matrix(c(x1,x2),ncol=2)
y=matrix(as.vector(Yij[,]))
Beta_hat=coefs_barbarian(x,y)
Beta_hat
X
x=matrix(c(x1,x2),ncol=2)
Xij=M[,,1:length(Beta_0)]
Yij=M[,,length(Beta_0)+1]
Xij
x
y
l
x
y
l<-lm(y~x)
l
dim(x)
lengt(is.na(x))
sum(is.na(x))
sum(!is.na(x))
n
Xij
dim(Xij)
dim(Yij)
dim(Yij)==dim(Xij)[1:2]
all(dim(Yij)==dim(Xij)[1:2])
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message=paste("X has",dim(X)[1:2],"observations\Y has",dim(Y),"observations")
stop(message)
}
}
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message=paste("X has",dim(X)[1:2],"observations\Y has",dim(Y),"observations")
stop(message)
}
}
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message=paste("X has",as.char(dim(X)[1:2]),"observations\Y has",as.char(dim(Y)),"observations")
stop(message)
}
}
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message=paste("X has",as.char(dim(X)[1:2]),"observations\Y has",as.char(dim(Y)),"observations")
stop(message)
}
}
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message=paste("X has",as.char(dim(X)[1:2]),"observations\Y has",as.char(dim(Y)),"observations")
stop(message)
}
}
dim(X)
x
dim(x)
dim(Xij)
dim(Y)!=dim(X)[1:2]
dim(Yij)!=dim(Xij)[1:2]
dim(Yij)
typeof(dim(Yij))
class(dim(Yij))
as.char(dim(Yij))
as.character(dim(Yij))
as.string (dim(Yij))
paste(as.character (dim(Yij)))
paste("lele",as.character (dim(Yij)))
paste("lele",paste(as.character (dim(Yij))))
message=paste("X has",as.character(dim(X)[1]),as.character(dim(X)[2]),"observations\Y has",as.character(dim(Y)[1]),as.character(dim(Y)[2]),"observations")
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message=paste("X has",as.character(dim(X)[1]),as.character(dim(X)[2]),"observations\Y has",as.character(dim(Y)[1]),as.character(dim(Y)[2]),"observations")
stop(message)
}
}
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message = paste(dim(X)[1], dim(X)[2])
stop(message)
}
}
J(Xij,Yij)
J(Xij,x)
paste(dim(Xij)[1],dim(Xij)[2])
t
typeof(t)
is.array(t)
dim(t)
J(X,t)
J(Xij,t)
help(stop)
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message = paste(dim(X)[1], dim(X)[2])
stop('message')
}
}
J(Xij,y)
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
message = paste(dim(X)[1], dim(X)[2])
stop(message)
}
}
J(Xij,y)
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
messageX = paste("dimension of X", dim(X)[1], dim(X)[2])
messageY = paste("\ndimension of Y", dim(Y)[1], dim(Y)[2])
stop(paste(messageX,messageY))
}
}
J(Xij,y)
J<-function(X,Y){
if (any(dim(Y)!=dim(X)[1:2])){
messageX = paste("2 first dimensions of X", dim(X)[1], dim(X)[2])
messageY = paste("\n 2 first dimensions of Y", dim(Y)[1], dim(Y)[2])
stop(paste(messageX,messageY))
}
}
J(Xij,Yij)
help(apply)
is.na(Xij)
any(is.na(Xij))
X
Xij
m
m=array(0, dim=c(10,10,3))
m
m[,,1]=1
m[,,1]=2
m[,,2]=2
m
m[,,2]=1
m
apply(m,c(1,3),mean)
apply(m,c(1,2),mean)
apply(m,c(1,3),mean)
okok
nice
noice
apply(m,c(1,3),mean)
